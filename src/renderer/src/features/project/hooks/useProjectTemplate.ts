/**
 * 프로젝트 템플릿 선택 및 생성
 */

import { useCallback } from "react";
import { useProjectStore } from "@renderer/features/project/stores/projectStore";
import { useChapterStore } from "@renderer/features/manuscript/stores/chapterStore";
import { useUIStore } from "@renderer/features/workspace/stores/uiStore";
import { api } from "@shared/api";
import { i18n } from "@renderer/i18n";
import {
  LUIE_MANUSCRIPT_DIR,
  LUIE_MANUSCRIPT_README,
  LUIE_PACKAGE_CONTAINER_DIR,
  LUIE_PACKAGE_EXTENSION,
  LUIE_PACKAGE_FORMAT,
  LUIE_PACKAGE_VERSION,
  MARKDOWN_EXTENSION,
  TEXT_EXTENSION,
  APP_NAME,
} from "@shared/constants";

const assertIpcSuccess = (
  response: { success: boolean; error?: { code?: string; message?: string } },
  operation: string,
) => {
  if (response.success) return;
  const code = response.error?.code ?? "UNKNOWN_ERROR";
  const message = response.error?.message ?? "IPC call failed";
  throw new Error(`${operation}:${code}:${message}`);
};

export function useProjectTemplate(setActiveChapterId: (id: string) => void) {
  const { createProject, setCurrentProject } = useProjectStore();
  const { create: createChapter } = useChapterStore();
  const { setView } = useUIStore();

  const handleSelectProject = useCallback(
    async (templateId: string, projectPath: string) => {
      let projectTitle = i18n.t("project.defaults.projectTitle");

      switch (templateId) {
        case "blank":
          projectTitle = i18n.t("project.defaults.newProjectTitle");
          break;
        case "novel_basic":
          projectTitle = i18n.t("settings.projectTemplate.title.webNovel");
          break;
        case "script_basic":
          projectTitle = i18n.t("settings.projectTemplate.title.screenplay");
          break;
        case "essay":
          projectTitle = i18n.t("settings.projectTemplate.title.essay");
          break;
      }

      const description = i18n.t("project.templateDescription", { templateId });

      const newProject = await createProject(
        projectTitle,
        description,
        projectPath,
      );

      if (newProject) {
        // 파일/패키지 저장
        try {
          const lower = projectPath.toLowerCase();
          const isMarkdown = lower.endsWith(MARKDOWN_EXTENSION);
          const isText = lower.endsWith(TEXT_EXTENSION);
          const isLuiePackage = lower.endsWith(LUIE_PACKAGE_EXTENSION);

          const content = isMarkdown
            ? `# ${newProject.title}\n\n## ${i18n.t("project.defaults.chapterTitle")}\n\n`
            : isText
              ? `${newProject.title}\n\n`
              : JSON.stringify(
                  {
                    format: LUIE_PACKAGE_FORMAT,
                    container: LUIE_PACKAGE_CONTAINER_DIR,
                    version: LUIE_PACKAGE_VERSION,
                    projectId: newProject.id,
                    title: newProject.title,
                    templateId,
                    createdAt: newProject.createdAt,
                    updatedAt: newProject.updatedAt,
                  },
                  null,
                  2,
                );

          if (isLuiePackage) {
            // 1) Create package structure
            const createResponse = await api.fs.createLuiePackage(projectPath, {
              format: LUIE_PACKAGE_FORMAT,
              container: LUIE_PACKAGE_CONTAINER_DIR,
              version: LUIE_PACKAGE_VERSION,
              projectId: newProject.id,
              title: newProject.title,
              templateId,
              createdAt: newProject.createdAt,
              updatedAt: newProject.updatedAt,
            });
            assertIpcSuccess(createResponse, "CREATE_LUIE_PACKAGE_FAILED");

            // 2) Write initial meta.json (already written) + placeholder manuscript index
            const writeReadmeResponse = await api.fs.writeProjectFile(
              projectPath,
              LUIE_MANUSCRIPT_README,
              `# ${newProject.title}\n\nGenerated by ${APP_NAME}.\n`,
            );
            assertIpcSuccess(writeReadmeResponse, "WRITE_LUIE_README_FAILED");
          } else {
            const writeFileResponse = await api.fs.writeFile(projectPath, content);
            assertIpcSuccess(writeFileResponse, "WRITE_PROJECT_FILE_FAILED");
          }
        } catch (e) {
          api.logger.error("Failed to save project file", e);
        }

        setCurrentProject(newProject);
        const firstChapter = await createChapter({
          projectId: newProject.id,
          title: i18n.t("project.defaults.chapterTitle"),
        });

        // If this is a .luie package, also persist chapter content into the package
        if (firstChapter?.id && projectPath.toLowerCase().endsWith(LUIE_PACKAGE_EXTENSION)) {
          try {
            const writeChapterResponse = await api.fs.writeProjectFile(
              projectPath,
              `${LUIE_MANUSCRIPT_DIR}/${firstChapter.id}${MARKDOWN_EXTENSION}`,
              "",
            );
            assertIpcSuccess(writeChapterResponse, "WRITE_INITIAL_CHAPTER_FAILED");
          } catch (e) {
            api.logger.warn("Failed to write initial chapter file", e);
          }
        }

        if (firstChapter?.id) {
          setActiveChapterId(firstChapter.id);
        }
        setView("editor");
      }
    },
    [createProject, setCurrentProject, createChapter, setView, setActiveChapterId],
  );

  return { handleSelectProject };
}
