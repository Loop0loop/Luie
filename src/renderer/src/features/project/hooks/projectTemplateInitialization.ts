import {
  APP_NAME,
  LUIE_MANUSCRIPT_DIR,
  LUIE_MANUSCRIPT_README,
  LUIE_PACKAGE_CONTAINER_DIR,
  LUIE_PACKAGE_EXTENSION,
  LUIE_PACKAGE_FORMAT,
  LUIE_PACKAGE_VERSION,
  MARKDOWN_EXTENSION,
  TEXT_EXTENSION,
} from "@shared/constants";

type IpcFailure = {
  code?: string;
  message?: string;
};

type IpcResponse = {
  success: boolean;
  data?: unknown;
  error?: IpcFailure;
};

type ProjectSeed = {
  id: string;
  title: string;
  createdAt?: string | Date;
  updatedAt?: string | Date;
};

type InitProjectInput = {
  project: ProjectSeed;
  projectPath: string;
  templateId: string;
  defaultChapterTitle: string;
};

type InitProjectDeps = {
  fs: {
    createLuiePackage: (projectPath: string, meta: unknown) => Promise<IpcResponse>;
    writeProjectFile: (
      projectPath: string,
      relativePath: string,
      content: string,
    ) => Promise<IpcResponse>;
    writeFile: (projectPath: string, content: string) => Promise<IpcResponse>;
  };
  createChapter: (input: { projectId: string; title: string }) => Promise<{ id?: string } | null | undefined>;
  deleteProject: (projectId: string) => Promise<unknown>;
  logger: {
    error: (message: string, data?: unknown) => unknown;
  };
};

const assertIpcSuccess = (response: IpcResponse, operation: string) => {
  if (response.success) return;
  const code = response.error?.code ?? "UNKNOWN_ERROR";
  const message = response.error?.message ?? "IPC call failed";
  throw new Error(`${operation}:${code}:${message}`);
};

const buildInitialContent = (
  projectTitle: string,
  chapterTitle: string,
  project: ProjectSeed,
  templateId: string,
  projectPath: string,
): string => {
  const lower = projectPath.toLowerCase();
  if (lower.endsWith(MARKDOWN_EXTENSION)) {
    return `# ${projectTitle}\n\n## ${chapterTitle}\n\n`;
  }
  if (lower.endsWith(TEXT_EXTENSION)) {
    return `${projectTitle}\n\n`;
  }
  return JSON.stringify(
    {
      format: LUIE_PACKAGE_FORMAT,
      container: LUIE_PACKAGE_CONTAINER_DIR,
      version: LUIE_PACKAGE_VERSION,
      projectId: project.id,
      title: project.title,
      templateId,
      createdAt: project.createdAt,
      updatedAt: project.updatedAt,
    },
    null,
    2,
  );
};

export const initializeTemplateProject = async (
  input: InitProjectInput,
  deps: InitProjectDeps,
): Promise<{ chapterId: string; projectPath?: string } | null> => {
  const { project, projectPath, templateId, defaultChapterTitle } = input;
  const isLuiePackage = projectPath.toLowerCase().endsWith(LUIE_PACKAGE_EXTENSION);

  try {
    let resolvedProjectPath = projectPath;

    if (isLuiePackage) {
      const createResponse = await deps.fs.createLuiePackage(projectPath, {
        format: LUIE_PACKAGE_FORMAT,
        container: LUIE_PACKAGE_CONTAINER_DIR,
        version: LUIE_PACKAGE_VERSION,
        projectId: project.id,
        title: project.title,
        templateId,
        createdAt: project.createdAt,
        updatedAt: project.updatedAt,
      });
      assertIpcSuccess(createResponse, "CREATE_LUIE_PACKAGE_FAILED");
      const createdPath =
        createResponse.data &&
        typeof createResponse.data === "object" &&
        "path" in createResponse.data
          ? (createResponse.data as { path?: unknown }).path
          : undefined;
      if (typeof createdPath === "string" && createdPath.trim().length > 0) {
        resolvedProjectPath = createdPath;
      }

      const readmeResponse = await deps.fs.writeProjectFile(
        resolvedProjectPath,
        LUIE_MANUSCRIPT_README,
        `# ${project.title}\n\nGenerated by ${APP_NAME}.\n`,
      );
      assertIpcSuccess(readmeResponse, "WRITE_LUIE_README_FAILED");
    } else {
      const content = buildInitialContent(
        project.title,
        defaultChapterTitle,
        project,
        templateId,
        projectPath,
      );
      const writeFileResponse = await deps.fs.writeFile(projectPath, content);
      assertIpcSuccess(writeFileResponse, "WRITE_PROJECT_FILE_FAILED");
    }

    const firstChapter = await deps.createChapter({
      projectId: project.id,
      title: defaultChapterTitle,
    });
    const chapterId = typeof firstChapter?.id === "string" ? firstChapter.id : "";
    if (!chapterId) {
      throw new Error("CREATE_INITIAL_CHAPTER_FAILED");
    }

    if (isLuiePackage) {
      const chapterWriteResponse = await deps.fs.writeProjectFile(
        resolvedProjectPath,
        `${LUIE_MANUSCRIPT_DIR}/${chapterId}${MARKDOWN_EXTENSION}`,
        "",
      );
      assertIpcSuccess(chapterWriteResponse, "WRITE_INITIAL_CHAPTER_FAILED");
    }

    return {
      chapterId,
      projectPath: isLuiePackage ? resolvedProjectPath : undefined,
    };
  } catch (error) {
    deps.logger.error("Failed to initialize template project storage", {
      projectId: project.id,
      projectPath,
      error,
    });
    try {
      await deps.deleteProject(project.id);
    } catch (rollbackError) {
      deps.logger.error("Failed to rollback template project initialization", {
        projectId: project.id,
        projectPath,
        error: rollbackError,
      });
    }
    return null;
  }
};
